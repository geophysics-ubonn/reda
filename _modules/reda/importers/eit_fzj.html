
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>reda.importers.eit_fzj &#8212; REDA 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/reda_logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Reproducible electrical data analysis</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_containers.html">Data Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../importers.html">Data Importers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file_formats/example_tsert.html">TSERT – Time Series ERT file format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filtering.html">Filtering Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../debugging.html">Debugging reda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_data.html">Test data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/geophysics-ubonn/reda">Source code</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../reda.html">reda</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for reda.importers.eit_fzj</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Import data from the EIT-systems built at the Research Center Jülich (FZJ).</span>

<span class="sd">As there is an increasing number of slightly different file formats in use,</span>
<span class="sd">this module acts as an selector for the appropriate import functions.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="c1"># import logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>

<span class="kn">import</span> <span class="nn">reda.importers.eit_version_2010</span> <span class="k">as</span> <span class="nn">eit_version_2010</span>
<span class="kn">import</span> <span class="nn">reda.importers.eit_version_2013</span> <span class="k">as</span> <span class="nn">eit_version_2013</span>
<span class="kn">import</span> <span class="nn">reda.importers.eit_version_2017</span> <span class="k">as</span> <span class="nn">eit_version_2017</span>
<span class="kn">import</span> <span class="nn">reda.importers.eit_version_2018a</span> <span class="k">as</span> <span class="nn">eit_version_2018a</span>
<span class="kn">import</span> <span class="nn">reda.importers.eit_version_20200609</span> <span class="k">as</span> <span class="nn">eit_version_20200609</span>
<span class="kn">from</span> <span class="nn">reda.importers.fzj_readbin</span> <span class="kn">import</span> <span class="n">fzj_readbin</span>

<span class="kn">from</span> <span class="nn">reda.importers.utils.decorators</span> <span class="kn">import</span> <span class="n">enable_result_transforms</span>

<span class="kn">from</span> <span class="nn">reda.configs.configManager</span> <span class="kn">import</span> <span class="n">ConfigManager</span>

<span class="c1"># data file formats differ slightly between versions. Version numbers do not</span>
<span class="c1"># follow a consistent naming scheme. Therefore we introduce this dict to map</span>
<span class="c1"># the version numbers found in the .mat files to the reda python modules.</span>
<span class="n">mat_version_importers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># this is the file version used for the 160 channel multiplexer system</span>
    <span class="s1">&#39;FZJ-EZ-2018A&#39;</span><span class="p">:</span> <span class="n">eit_version_2018a</span><span class="p">,</span>
    <span class="s1">&#39;FZJ-EZ-2017&#39;</span><span class="p">:</span> <span class="n">eit_version_2017</span><span class="p">,</span>
    <span class="s1">&#39;FZJ-EZ-09.11.2010&#39;</span><span class="p">:</span> <span class="n">eit_version_2010</span><span class="p">,</span>
    <span class="s1">&#39;FZJ-EZ-14.02.2013&#39;</span><span class="p">:</span> <span class="n">eit_version_2013</span><span class="p">,</span>
    <span class="s1">&#39;EZ-2020-06-09&#39;</span><span class="p">:</span> <span class="n">eit_version_20200609</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_get_file_version</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;High level import function that tries to determine the specific version</span>
<span class="sd">    of the data format used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename: string</span>
<span class="sd">        File path to a .mat matlab filename, as produced by the various</span>
<span class="sd">        versions of the emmt_pp.exe postprocessing program.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    version: string</span>
<span class="sd">        a sanitized version of the file format version</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">squeeze_me</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="s1">&#39;MP&#39;</span><span class="p">][</span><span class="s1">&#39;Version&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">del</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">version</span>


<div class="viewcode-block" id="MD_ConfigsPermutate"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.MD_ConfigsPermutate">[docs]</a><span class="k">def</span> <span class="nf">MD_ConfigsPermutate</span><span class="p">(</span><span class="n">df_md</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a MD DataFrame, return a Nx4 array which permutes the current</span>
<span class="sd">    injection dipoles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g_current_injections</span> <span class="o">=</span> <span class="n">df_md</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g_current_injections</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">config_mgr</span> <span class="o">=</span> <span class="n">ConfigManager</span><span class="p">(</span><span class="n">nr_of_electrodes</span><span class="o">=</span><span class="n">ab</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">config_mgr</span><span class="o">.</span><span class="n">gen_configs_permutate</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">config_mgr</span><span class="o">.</span><span class="n">configs</span></div>


<div class="viewcode-block" id="get_mnu0_data"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.get_mnu0_data">[docs]</a><span class="k">def</span> <span class="nf">get_mnu0_data</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">configs</span><span class="p">,</span> <span class="n">return_3p</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import data post-processed as 3P data (NMU0), i.e., measured towards</span>
<span class="sd">    common ground.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : string (usually: eit_data_mnu0.mat)</span>
<span class="sd">        filename of matlab file</span>
<span class="sd">    configs : Nx4 numpy.ndarray|filename|function</span>
<span class="sd">        4P measurements configurations (ABMN) to generate out of the data. If</span>
<span class="sd">        this parameter is a callable, then call it with the MD DataFrame as its</span>
<span class="sd">        sole parameter and expect a Nx4 numpy.ndarray as return value</span>
<span class="sd">    return_3p : bool, optional</span>
<span class="sd">        also return 3P data</span>

<span class="sd">    Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    multiplexer_group : int|None, optional</span>
<span class="sd">        For the multiplexer system (version 2018a) the multiplexer group MUST</span>
<span class="sd">        be specified to import data. This is a number between 1 and 4.</span>
<span class="sd">    compute_errors : None|str, optional</span>
<span class="sd">        If this parameter points to the .bin file containing the raw data, then</span>
<span class="sd">        compute data errors based on a noise level analysis of individual time</span>
<span class="sd">        series. Time-consuming!</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_emd_4p : pandas.DataFrame</span>
<span class="sd">        The generated 4P data</span>
<span class="sd">    data_md_raw : pandas.DataFrame|None</span>
<span class="sd">        MD data (sometimes this data is not imported, then we return None here)</span>
<span class="sd">    data_emd_3p : pandas.DataFrame</span>
<span class="sd">        The imported 3P data (only if return_3p==True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Data file not found! </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="n">version</span> <span class="o">=</span> <span class="n">_get_file_version</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">importer</span> <span class="o">=</span> <span class="n">mat_version_importers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">importer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">squeeze_me</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data_md_raw</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">_extract_md</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">data_emd_3p</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">_extract_emd</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># check configs</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">configs</span><span class="p">):</span>
            <span class="n">configs_abmn</span> <span class="o">=</span> <span class="n">configs</span><span class="p">(</span><span class="n">data_md_raw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">configs_abmn</span> <span class="o">=</span> <span class="n">configs</span>

        <span class="k">if</span> <span class="n">data_emd_3p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_emd_4p</span> <span class="o">=</span> <span class="n">compute_quadrupoles</span><span class="p">(</span>
                <span class="n">data_emd_3p</span><span class="p">,</span> <span class="n">configs_abmn</span><span class="p">,</span> <span class="n">data_md_raw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_emd_4p</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">binary_file</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;compute_errors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binary_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span>
                <span class="n">binary_file</span><span class="p">),</span> <span class="s1">&#39;compute_errors must point to a valid .bin file&#39;</span>

            <span class="n">adc_data</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">_extract_adc_data</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">data_emd_4p</span> <span class="o">=</span> <span class="n">compute_data_errors</span><span class="p">(</span>
                <span class="n">data_emd_4p</span><span class="p">,</span>
                <span class="n">data_md_raw</span><span class="p">,</span>
                <span class="n">adc_data</span><span class="p">,</span>
                <span class="n">binary_file</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">&#39;The file version &quot;</span><span class="si">{}</span><span class="s1">&quot; is not supported yet.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">version</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_3p</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_emd_4p</span><span class="p">,</span> <span class="n">data_md_raw</span><span class="p">,</span> <span class="n">data_emd_3p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_emd_4p</span><span class="p">,</span> <span class="n">data_md_raw</span></div>


<div class="viewcode-block" id="get_md_data"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.get_md_data">[docs]</a><span class="k">def</span> <span class="nf">get_md_data</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import data and return the MD (i.e., injection) data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : string (usually: eit_data_mnu0.mat)</span>
<span class="sd">        filename of matlab file</span>

<span class="sd">    Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    multiplexer_group : int|None, optional</span>
<span class="sd">        For the multiplexer system (version 2018a) the multiplexer group MUST</span>
<span class="sd">        be specified to import data. This is a number between 1 and 4.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_md_raw : pandas.DataFrame|None</span>
<span class="sd">        MD data (sometimes this data is not imported, then we return None here)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Data file not found! </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="n">version</span> <span class="o">=</span> <span class="n">_get_file_version</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">importer</span> <span class="o">=</span> <span class="n">mat_version_importers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">importer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">squeeze_me</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data_md_raw</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">_extract_md</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_md_raw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;emmt_pp version not found: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">version</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_adc_data"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.get_adc_data">[docs]</a><span class="k">def</span> <span class="nf">get_adc_data</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import data and return the adc-related data from the MD (i.e.,</span>
<span class="sd">    injection) structure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : string (usually: eit_data_mnu0.mat)</span>
<span class="sd">        filename of matlab file</span>

<span class="sd">    Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    multiplexer_group : int|None, optional</span>
<span class="sd">        For the multiplexer system (version 2018a) the multiplexer group MUST</span>
<span class="sd">        be specified to import data. This is a number between 1 and 4.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_adc_raw : pandas.DataFrame|None</span>
<span class="sd">        adc-MD data (sometimes this data is not imported, then we return None</span>
<span class="sd">        here)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Data file not found! </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="n">version</span> <span class="o">=</span> <span class="n">_get_file_version</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">importer</span> <span class="o">=</span> <span class="n">mat_version_importers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">importer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">squeeze_me</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data_md_raw</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">_extract_adc_data</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_md_raw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;emmt_pp version not found: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">version</span><span class="p">))</span></div>


<div class="viewcode-block" id="read_3p_data"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.read_3p_data">[docs]</a><span class="nd">@enable_result_transforms</span>
<span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">get_mnu0_data</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_3p_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># this is a wrapper that conforms to the importer standards</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">get_mnu0_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">df_emd</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df_emd</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="compute_quadrupoles"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.compute_quadrupoles">[docs]</a><span class="k">def</span> <span class="nf">compute_quadrupoles</span><span class="p">(</span><span class="n">df_emd</span><span class="p">,</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">df_md</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_emd : pandas.DataFrame</span>
<span class="sd">        The EMD data, as imported from the .mat file (3P-data)</span>
<span class="sd">    config_file : string</span>
<span class="sd">        filename for configuration file. The configuration file contains N rows</span>
<span class="sd">        with 4 columns each (A, B, M, N)</span>
<span class="sd">    df_md : pandas.DataFrame (optional)</span>
<span class="sd">        The MD data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># &#39;configs&#39; can be a numpy array or a filename</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config_file</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">configs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">config_file</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">configs</span> <span class="o">=</span> <span class="n">config_file</span>

    <span class="n">configs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">configs</span><span class="p">)</span>

    <span class="c1"># construct four-point measurements via superposition</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing four-point measurements&#39;</span><span class="p">)</span>
    <span class="n">quadpole_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">Ar</span><span class="p">,</span> <span class="n">Br</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">configs</span><span class="p">:</span>
        <span class="c1"># print(&#39;constructing&#39;, Ar, Br, M, N)</span>
        <span class="c1"># the order of A and B doesn&#39;t concern us</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">Ar</span><span class="p">,</span> <span class="n">Br</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">Ar</span><span class="p">,</span> <span class="n">Br</span><span class="p">))</span>

        <span class="c1"># first choice: correct ordering</span>
        <span class="n">query_M</span> <span class="o">=</span> <span class="n">df_emd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a==</span><span class="si">{0}</span><span class="s1"> and b==</span><span class="si">{1}</span><span class="s1"> and p==</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">M</span>
        <span class="p">))</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span>
        <span class="n">query_N</span> <span class="o">=</span> <span class="n">df_emd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a==</span><span class="si">{0}</span><span class="s1"> and b==</span><span class="si">{1}</span><span class="s1"> and p==</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span>
        <span class="p">))</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">query_M</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">query_N</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">query_M</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">query_N</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;There is something wrong with the data, different sized &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;data sets for M and N&#39;</span>
            <span class="p">)</span>

        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># keep these columns as they are (no subtracting)</span>
        <span class="n">keep_cols_all</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;datetime&#39;</span><span class="p">,</span>
            <span class="s1">&#39;frequency&#39;</span><span class="p">,</span>
            <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Zg1&#39;</span><span class="p">,</span> <span class="s1">&#39;Zg2&#39;</span><span class="p">,</span> <span class="s1">&#39;Zg3&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Zg&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Is&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Il&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Iab&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Ileakage&#39;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="c1"># only keep those are actually there</span>
        <span class="n">keep_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keep_cols_all</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">query_M</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="n">df4</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">diff_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Zt&#39;</span><span class="p">,</span> <span class="p">]</span>
        <span class="n">df4</span><span class="p">[</span><span class="n">keep_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_M</span><span class="p">[</span><span class="n">keep_cols</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">diff_cols</span><span class="p">:</span>
            <span class="n">df4</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_M</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">query_N</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">df4</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_M</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">df4</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">query_N</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">quadpole_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">quadpole_list</span><span class="p">:</span>
        <span class="n">dfn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">quadpole_list</span><span class="p">)</span>
        <span class="n">Rsign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Zt&#39;</span><span class="p">]))</span>
        <span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rsign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Zt&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;Iab&#39;</span> <span class="ow">in</span> <span class="n">dfn</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Vmn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Iab&#39;</span><span class="p">]</span>
        <span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;rpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Zt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="s1">&#39;Zt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="mf">1e3</span>
        <span class="c1"># Depending on the specific analysis software ware, some columns are</span>
        <span class="c1"># located in the md struct and need to be merged to the dfn</span>
        <span class="n">check_md_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;Zg&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Iab&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Ileakage&#39;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">check_md_columns</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dfn</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">df_md</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">column</span> <span class="ow">in</span> <span class="n">df_md</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding column </span><span class="si">{}</span><span class="s1"> from MD&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
                <span class="c1"># import IPython</span>
                <span class="c1"># IPython.embed()</span>
                <span class="n">dfn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">dfn</span><span class="p">,</span>
                    <span class="n">df_md</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">]],</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dfn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dfn</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="apply_correction_factors"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.apply_correction_factors">[docs]</a><span class="k">def</span> <span class="nf">apply_correction_factors</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">correction_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply correction factors for a pseudo-2D measurement setup. See Weigand</span>
<span class="sd">    and Kemna, 2017, Biogeosciences, for detailed information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : :py:class:`pandas.DataFrame`</span>
<span class="sd">        DataFrame containing the data</span>
<span class="sd">    correction_data : string|iterable of strings|:py:class:`numpy.ndarray`</span>
<span class="sd">        Correction data, either as a filename, a list of filenames to be</span>
<span class="sd">        merged, or directly as a numpy array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Corrected data</span>
<span class="sd">    corr_data : :py:class:`numpy.ndarray`</span>
<span class="sd">        Correction factors used</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correction_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">corr_data_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">correction_data</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correction_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">corr_data_raw</span> <span class="o">=</span> <span class="n">correction_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># assume only one data file</span>
        <span class="n">corr_data_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">correction_data</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">corr_data_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="c1"># if required, convert from CRTomo electrode denotations in (a,b,m,n) style</span>
    <span class="k">if</span> <span class="n">corr_data_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">corr_data_raw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">corr_data_raw</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mf">1e4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">corr_data_raw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">corr_data_raw</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mf">1e4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">corr_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">corr_data_raw</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corr_data</span> <span class="o">=</span> <span class="n">corr_data_raw</span>

    <span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># if &#39;frequency&#39; not in df.columns:</span>
    <span class="c1">#     raise Exception(</span>
    <span class="c1">#         &#39;No frequency data found. Are you sure this is a seit data set?&#39;</span>
    <span class="c1">#     )</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">gf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">gf</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># print(&#39;key&#39;, key)</span>
        <span class="c1"># print(item)</span>
        <span class="n">item_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])))</span>
        <span class="c1"># print(item_norm)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">item_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">item_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">item_norm</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">corr_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">item_norm</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(index, corr_data[index])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;No correction factor found for this configuration&#39;</span>
            <span class="p">)</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">*</span> <span class="n">corr_data</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="c1"># apply correction factor</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;Zt&#39;</span><span class="p">,</span> <span class="s1">&#39;Vmn&#39;</span><span class="p">,</span> <span class="s1">&#39;rho_a&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">item</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="c1"># add the correction factor to the DataFrame</span>
        <span class="k">if</span> <span class="s1">&#39;corr_fac&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;corr_fac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">item</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;corr_fac&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">corr_data</span></div>


<div class="viewcode-block" id="compute_data_errors"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.compute_data_errors">[docs]</a><span class="k">def</span> <span class="nf">compute_data_errors</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">,</span> <span class="n">data_md_raw</span><span class="p">,</span> <span class="n">adc_data</span><span class="p">,</span> <span class="n">binary_file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute data errors based on a noise-level analysis and subsequent</span>
<span class="sd">    linear error propagation.</span>

<span class="sd">    Additional Parameters</span>
<span class="sd">    ---------------------</span>
<span class="sd">    error_model_use_diff_noise_level : bool, optional (default: False)</span>

<span class="sd">    What we need in data_emd_4p:</span>

<span class="sd">        * phi_m</span>
<span class="sd">        * phi_n</span>
<span class="sd">        * dphi_m</span>
<span class="sd">        * dphi_n</span>
<span class="sd">        * current (complex)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Preparing data_emd_4p&#39;</span><span class="p">)</span>
    <span class="c1"># print(&#39;Merging in complex current&#39;)</span>
    <span class="c1"># import IPython</span>
    <span class="c1"># IPython.embed()</span>

    <span class="k">if</span> <span class="s1">&#39;Is&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_emd_4p</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">data_emd_4p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">data_emd_4p</span><span class="p">,</span>
            <span class="n">data_md_raw</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;Is&#39;</span><span class="p">]],</span>
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">],</span>
            <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Add electrode potentials&#39;</span><span class="p">)</span>
    <span class="n">us3</span> <span class="o">=</span> <span class="n">adc_data</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;Us&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">us3_selected</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">]],</span>
        <span class="n">us3</span><span class="p">,</span>
        <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">],</span>
        <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">])</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">us3_selected</span><span class="o">.</span><span class="n">values</span><span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">us3_selected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">us3_selected</span><span class="o">.</span><span class="n">values</span><span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">us3_selected</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="n">fzj_readbin</span><span class="p">(</span><span class="n">binary_file</span><span class="p">)</span>

    <span class="c1"># check = (data_emd_4p[&#39;pot_m&#39;] - data_emd_4p[&#39;pot_n&#39;]) / data_emd_4p[&#39;Is&#39;]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compute noise levels&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_noise_levels</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">find_swapped_measurement_indices</span><span class="p">(</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;frequency&#39;</span><span class="p">],</span>
            <span class="n">row</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">noise_levels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="c1"># try to remove systematic components</span>
            <span class="n">ts_m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">ts_n</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">ts_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts_m</span> <span class="o">-</span> <span class="n">ts_m</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">-</span> <span class="p">(</span><span class="n">ts_n</span> <span class="o">-</span> <span class="n">ts_n</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

            <span class="n">fdata</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">frequency_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">fdata</span><span class="p">[</span><span class="s1">&#39;sampling_frequency&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">fdata</span><span class="p">[</span><span class="s1">&#39;oversampling&#39;</span><span class="p">]</span>

            <span class="n">fft</span><span class="p">,</span> <span class="n">u_peaks</span><span class="p">,</span> <span class="n">noise_level</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_noise_level_from_fft</span><span class="p">(</span>
                <span class="n">ts_diff</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># now analyze the channels separately</span>
            <span class="n">level1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fft_analysis_one_channel</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">],</span>
                <span class="n">remove_excitation_frequency</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;remove_excitation_frequency&#39;</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">),</span>
                <span class="n">remove_noise_harmonics</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;remove_noise_harmonics&#39;</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">),</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">level2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fft_analysis_one_channel</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                <span class="n">remove_excitation_frequency</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;remove_excitation_frequency&#39;</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">),</span>
                <span class="n">remove_noise_harmonics</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;remove_noise_harmonics&#39;</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">),</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># noise level of difference of both time series</span>
            <span class="c1"># logger = logging.getLogger()</span>
            <span class="c1"># logger.warning(</span>
            <span class="c1">#     &quot;IMPORTANT: I&#39;m using the noise level of the ts-difference!&quot;)</span>
            <span class="c1"># we assume that the resulting noise component is the result of</span>
            <span class="c1"># both equally sized noise components of the single time series:</span>
            <span class="c1"># diff = t1 - t2</span>
            <span class="c1"># -&gt; d_diff = sqrt(dt1** 2 + dt2 ** 2)</span>
            <span class="c1"># if we assume dt1 == dt2, then</span>
            <span class="c1"># dt1 = dt2 = 1 / np.sqrt(2) d_diff</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;error_model_use_diff_noise_level&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">noise_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noise_level</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">noise_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noise_level</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># individual channel noise levels</span>
                <span class="n">noise_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level1</span><span class="p">)</span>
                <span class="n">noise_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level2</span><span class="p">)</span>

            <span class="c1"># current channel noise analysis</span>
            <span class="c1"># TODO: Do properly, for now we only analyse channel 41</span>
            <span class="n">ts_current</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">41</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">fft</span><span class="p">,</span> <span class="n">u_peaks</span><span class="p">,</span> <span class="n">noise_level_current</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_noise_level_from_fft</span><span class="p">(</span>
                <span class="n">ts_current</span> <span class="o">-</span> <span class="n">ts_current</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">noise_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noise_level_current</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">noise_levels</span><span class="p">)</span>

    <span class="n">noise_levels</span> <span class="o">=</span> <span class="n">data_emd_4p</span><span class="p">[</span>
        <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_noise_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

    <span class="n">noise_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">noise_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># hack: convert to voltages: FFT &lt;-&gt; voltage noise level</span>
    <span class="n">noise_levels</span> <span class="o">/=</span> <span class="mi">48</span>

    <span class="c1"># propagate noise level on time -series down through the lockin</span>
    <span class="n">noise_levels</span> <span class="o">/=</span> <span class="mi">40</span>

    <span class="c1"># import IPython</span>
    <span class="c1"># IPython.embed()</span>

    <span class="c1"># regular injection</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># swapped injection</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_levels</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span>

    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m_1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m_2&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n_1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n_2&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent_1&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent_2&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">)</span>

    <span class="n">magnitude_errors</span> <span class="o">=</span> <span class="n">compute_magnitude_errors</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;Is&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="c1"># test: 1 / sqrt(3) to simulate the three repetitions</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>  <span class="c1"># / np.sqrt(3),</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>  <span class="c1"># / np.sqrt(3),</span>
        <span class="n">dcurrent</span><span class="o">=</span><span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="c1"># dcurrent=np.array(0),</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">phase_errors</span> <span class="o">=</span> <span class="n">compute_phase_errors</span><span class="p">(</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;pot_n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;Is&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="c1"># test: 1 / sqrt(3) to simulate the three repetitions</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_m&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>  <span class="c1"># / np.sqrt(3),</span>
        <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dpot_n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>  <span class="c1"># / np.sqrt(3),</span>
        <span class="n">dcurrent</span><span class="o">=</span><span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;dcurrent&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="c1"># dcurrent=np.array(0),</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;r_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">magnitude_errors</span>
    <span class="n">data_emd_4p</span><span class="p">[</span><span class="s1">&#39;rpha_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_errors</span> <span class="o">*</span> <span class="mi">1000</span>

    <span class="c1"># import IPython</span>
    <span class="c1"># IPython.embed()</span>
    <span class="k">return</span> <span class="n">data_emd_4p</span></div>


<div class="viewcode-block" id="compute_magnitude_errors"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.compute_magnitude_errors">[docs]</a><span class="k">def</span> <span class="nf">compute_magnitude_errors</span><span class="p">(</span>
        <span class="n">phi_m</span><span class="p">,</span> <span class="n">phi_n</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">dphi_m</span><span class="p">,</span> <span class="n">dphi_n</span><span class="p">,</span> <span class="n">dcurrent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute magnitude errors based on linear error propagation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">error_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dphi_m</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="n">error_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dphi_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="n">error_current</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
        <span class="n">phi_m</span> <span class="o">-</span> <span class="n">phi_n</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">current</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dcurrent</span>

    <span class="n">error_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">error_m</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="n">error_n</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="n">error_current</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
        <span class="mi">0</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">error_magnitude</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_phase_errors"><a class="viewcode-back" href="../../../_api/reda.importers.html#reda.importers.eit_fzj.compute_phase_errors">[docs]</a><span class="k">def</span> <span class="nf">compute_phase_errors</span><span class="p">(</span>
        <span class="n">phi_m</span><span class="p">,</span> <span class="n">phi_n</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">dphi_m</span><span class="p">,</span> <span class="n">dphi_n</span><span class="p">,</span> <span class="n">dcurrent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the phase error based on linear error propagation of the</span>
<span class="sd">    transfer impedance equation:</span>

<span class="sd">        Zt = U_mn / I_ab = (phi_m - phi_n) / I_ab</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi_m : numpy.ndarray|complex float</span>
<span class="sd">        Complex potential at electrode m</span>
<span class="sd">    phi_n : numpy.ndarray|complex float</span>
<span class="sd">        Complex potential at electrode n</span>
<span class="sd">    current : numpy.ndarray|complex float</span>
<span class="sd">        Complex current injected at electrodes a and b</span>
<span class="sd">    dphi_m : numpy.ndarray|complex float</span>
<span class="sd">        potential error at electrode m. Real part corresponds to error of the</span>
<span class="sd">        real part of the potential, vice versa for the imaginary part</span>
<span class="sd">    dphi_n : numpy.ndarray|complex float</span>
<span class="sd">        potential error at electrode m. Real part corresponds to error of the</span>
<span class="sd">        real part of the potential, vice versa for the imaginary part</span>
<span class="sd">    dcurrent : numpy.ndarray|complex float</span>
<span class="sd">        current error at electrode m. Real part corresponds to error of the</span>
<span class="sd">        real part of the potential, vice versa for the imaginary part</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    error_phase : numpy.ndarray|float</span>
<span class="sd">        Phase error in [rad]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span> <span class="n">current</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">phi_m</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">real</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">current</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">current</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">phi_m</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">imag</span>
    <span class="p">)</span>

    <span class="c1"># chain rule: d/dx arctan(x) = 1 / (1 + x^2)</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">error_dphi_m_real</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="o">-</span><span class="n">current</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">B</span> <span class="o">+</span> <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">current</span><span class="o">.</span><span class="n">real</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dphi_m</span>

    <span class="n">error_dphi_n_real</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">current</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">current</span><span class="o">.</span><span class="n">real</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dphi_m</span>

    <span class="n">error_dphi_m_imag</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">current</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">B</span> <span class="o">+</span> <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">current</span><span class="o">.</span><span class="n">imag</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dphi_m</span>

    <span class="n">error_dphi_n_imag</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="o">-</span><span class="n">current</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">current</span><span class="o">.</span><span class="n">imag</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dphi_n</span>

    <span class="n">error_current_real</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span> <span class="o">+</span> <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dcurrent</span>

    <span class="n">error_current_imag</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">*</span> <span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span> <span class="o">+</span>
        <span class="n">A</span> <span class="o">/</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_m</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">phi_n</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">dcurrent</span>

    <span class="n">inner_term</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_dphi_m_real</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_dphi_n_real</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_dphi_m_imag</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_dphi_n_imag</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;errmod_pha_no_current_error&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_current_real</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">inner_term</span> <span class="o">+=</span> <span class="n">error_current_imag</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">phase_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">phase_error</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, M. Weigand and F. M. Wagner and others.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>